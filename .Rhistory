average_standard_deviation_t = c(average_standard_deviation_t, mean((distance - mean(distance))**2))
}
# plot graph for average step and standard deviation
plot(average_step_t, typ='l', main = paste("Average Steps vs. t - ", n, "nodes"), xlab = "t", ylab = "Average Steps")
plot(average_standard_deviation_t, typ='l', main = paste("Average Standard Deviation vs. t - ", n, "nodes"), xlab = "t", ylab = "Average Standard Deviation")
#### QUESTION 1 - PART E ####
if (node == 1000) {
deg_network = degree(random_network)
hist(x = deg_network, breaks = seq(from = min(deg_network), to = max(deg_network), by=1), main = "Degree Distribution for Random Undirected Graph (with n=1000)", xlab = "Number of Degrees")
hist(x = deg_random_walk, breaks = seq(from = min(deg_random_walk), to = max(deg_random_walk), by=1), main = "Degree Distribution at end of Random Walk", xlab = "Number of Degrees")
}
}
#### QUESTION 1 - PART A & B ####
cat("Executing for Random Network with 1000 nodes")
random_walker_func(node = 1000, 0.01)
# load igraph library
library(igraph)
library(netrw)
# function to perform random walker
random_walker_func = function(node, probability){
# draw random undirected graphs with above probability
random_network = random.graph.game(n = node, p = probability, directed = FALSE)
cat("Diameter of network with", node, "nodes = ", diameter(random_network))
average_step_t = numeric()
average_standard_deviation_t = numeric()
distance_matrix = shortest.paths(random_network, v = V(random_network), to = V(random_network))
deg_random_walk = numeric()
for (t in 1:50) {
distance = numeric()
vertex_sequence = netrw(random_network, walker.num = node, damping = 1, T = t, output.walk.path = TRUE)$walk.path # get vertex sequence of random walk
for(n in (1:node))
{
start_vertex = vertex_sequence[1,n]
tail_vertex = vertex_sequence[t,n]
shortest_distance = distance_matrix[start_vertex, tail_vertex]
# shortest_distance = get.shortest.paths(random_network, from = vertex_sequence[1,n], to = vertex_sequence[t,n])
# shortest_distance = length(shortest_distance$vpath[[1]])-1
if (shortest_distance == Inf) {
shortest_distance = 0
}
distance = c(distance, shortest_distance)
deg_random_walk = c(deg_random_walk, degree(random_network, v = tail_vertex))
}
average_step_t = c(average_step_t, mean(distance))
average_standard_deviation_t = c(average_standard_deviation_t, mean((distance - mean(distance))**2))
}
# plot graph for average step and standard deviation
plot(average_step_t, typ='l', main = paste("Average Steps vs. t - ", n, "nodes"), xlab = "t", ylab = "Average Steps")
plot(average_standard_deviation_t, typ='l', main = paste("Average Standard Deviation vs. t - ", n, "nodes"), xlab = "t", ylab = "Average Standard Deviation")
#### QUESTION 1 - PART E ####
if (node == 1000) {
deg_network = degree(random_network)
hist(x = deg_network, breaks = seq(from = min(deg_network), to = max(deg_network), by=1), main = "Degree Distribution for Random Undirected Graph (with n=1000)", xlab = "Number of Degrees")
hist(x = deg_random_walk, breaks = seq(from = min(deg_random_walk), to = max(deg_random_walk), by=1), main = "Degree Distribution at end of Random Walk", xlab = "Number of Degrees")
}
}
#### QUESTION 1 - PART A & B ####
cat("Executing for Random Network with 1000 nodes")
random_walker_func(node = 1000, 0.01)
# load igraph library
library(igraph)
library(netrw)
# function to perform random walker
random_walker_func = function(node, probability){
# draw random undirected graphs with above probability
random_network = random.graph.game(n = node, p = probability, directed = FALSE)
cat("Diameter of network with", node, "nodes = ", diameter(random_network))
average_step_t = numeric()
average_standard_deviation_t = numeric()
distance_matrix = shortest.paths(random_network, v = V(random_network), to = V(random_network))
deg_random_walk = numeric()
for (t in 1:50) {
distance = numeric()
vertex_sequence = netrw(random_network, walker.num = node, damping = 1, T = t, output.walk.path = TRUE)$walk.path # get vertex sequence of random walk
for(n in (1:node))
{
start_vertex = vertex_sequence[1,n]
tail_vertex = vertex_sequence[t,n]
shortest_distance = distance_matrix[start_vertex, tail_vertex]
# shortest_distance = get.shortest.paths(random_network, from = vertex_sequence[1,n], to = vertex_sequence[t,n])
# shortest_distance = length(shortest_distance$vpath[[1]])-1
if (shortest_distance == Inf) {
shortest_distance = 0
}
distance = c(distance, shortest_distance)
deg_random_walk = c(deg_random_walk, degree(random_network, v = tail_vertex))
}
average_step_t = c(average_step_t, mean(distance))
average_standard_deviation_t = c(average_standard_deviation_t, mean((distance - mean(distance))**2))
}
# plot graph for average step and standard deviation
plot(average_step_t, typ='l', main = paste("Average Steps vs. t - ", n, "nodes"), xlab = "t", ylab = "Average Steps")
plot(average_standard_deviation_t, typ='l', main = paste("Average Standard Deviation vs. t - ", n, "nodes"), xlab = "t", ylab = "Average Standard Deviation")
#### QUESTION 1 - PART E ####
if (node == 1000) {
deg_network = degree(random_network)
hist(x = deg_network, breaks = seq(from = min(deg_network), to = max(deg_network), by=1), main = "Degree Distribution for Random Undirected Graph (with n=1000)", xlab = "Number of Degrees")
hist(x = deg_random_walk, breaks = seq(from = min(deg_random_walk), to = max(deg_random_walk), by=1), main = "Degree Distribution at end of Random Walk", xlab = "Number of Degrees")
}
}
#### QUESTION 1 - PART A & B ####
cat("Executing for Random Network with 1000 nodes")
random_walker_func(node = 1000, 0.01)
version
ip <- as.data.frame(installed.packages()[,c(1,3:4)])
rownames(ip) <- NULL
ip <- ip[is.na(ip$Priority),1:2,drop=FALSE]
print(ip, row.names=FALSE)
# This code is programmed in R v2.15.2.with iGraph v0.7.0 and netrw v0.2.6
# Homework 2 Question 3
# clearing workspace
closeAllConnections()
rm(list=ls())
# Load libraries
library("igraph")
library("netrw")
# This code is programmed in R v2.15.2.with iGraph v0.7.0 and netrw v0.2.6
# Homework 2 Question 3
# clearing workspace
closeAllConnections()
rm(list=ls())
# Load libraries
library("igraph")
library("netrw")
############################### Part a ###############################
# generate graph from 1a
num_nodes <- 1000
g1 <- erdos.renyi.game(n = num_nodes, p = 0.01)
w_mat = netrw(g1, walker.num = num_nodes, damping = 1, T = num_nodes, output.walk.path = TRUE) # get vertex sequence of random walk
dim(w_mat)
# This code is programmed in R v2.15.2.with iGraph v0.7.0 and netrw v0.2.6
# Homework 2 Question 3
# clearing workspace
closeAllConnections()
rm(list=ls())
# Load libraries
library("igraph")
library("netrw")
############################### Part a ###############################
# generate graph from 1a
num_nodes <- 1000
num_steps <- 30
g1 <- erdos.renyi.game(n = num_nodes, p = 0.01)
w_mat = netrw(g1, walker.num = num_nodes, damping = 1, T = num_steps, output.walk.path = TRUE) # get vertex sequence of random walk
visit_probability = w_mat$ave.visit.prob
random_network = random.graph.game(n = 1000, p = 0.01, directed = FALSE)
vertex_sequence = netrw(random_network, walker.num = 1000, damping = 1, T = 1000, output.walk.path = TRUE) # get vertex sequence of random walk
network_degree = degree(random_network)
visit_probability = vertex_sequence$ave.visit.prob
relationship = cor(network_degree, visit_probability)
cat("Correlation between degree and visit probability: ", relationship)
plot_data = rbind(network_degree, visit_probability)
# This code is programmed in R v2.15.2.with iGraph v0.7.0 and netrw v0.2.6
# Homework 2 Question 3
# clearing workspace
closeAllConnections()
rm(list=ls())
# Load libraries
library("igraph")
library("netrw")
############################### Part a ###############################
# generate graph from 1a
num_nodes <- 1000
num_steps <- 30
g1 <- erdos.renyi.game(n = num_nodes, p = 0.01)
w_mat = netrw(g1, walker.num = num_nodes, damping = 1, T = num_steps, output.walk.path = TRUE) # get vertex sequence of random walk
visit_probability = w_mat$ave.visit.prob
g1_degree = order
g1_degree = degree(g1)
plot(g1_degree,visit_probability,type = "o")
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
closeAllConnections()
rm(list=ls())
library("igraph")
library("netrw")
num_nodes <- 1000
num_steps <- 30
g1 <- erdos.renyi.game(n = num_nodes, p = 0.01)
w_mat = netrw(g1, walker.num = num_nodes, damping = 1, T = num_steps, output.walk.path = TRUE) # get vertex sequence of random walk
visit_probability = w_mat$ave.visit.prob
g1_degree = degree(g1)
plot(g1_degree,visit_probability,type = "o")
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
plot(g1_degree,visit_probability)
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
abline(lm(g1_degree~visit_probability),col="red")
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
plot(g1_degree,visit_probability)
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q1.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
lm(g1_degree ~ visit_probability)
abline(2,7119)
abline(2,.7)
abline(1,1)
plot(1,1)
abline(1,1)
help abline
plot(1~1)
plot(1~1,type="b")
plot(1~1,type="b")
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
plot(g1_degree,visit_probability, main = "Visit Probability for Undirected Graph", xlab = "Degree", ylab = "Visiting Probability")
plot(g1_degree,visit_probability, main = "Visit Probability for Directed Graph", xlab = "Degree", ylab = "Visiting Probability"))
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q1.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
version
num_nodes <- 1000
num_steps <- 1000
g1 <-random.graph.game(n = num_nodes, p = 0.01 , directred = TRUE)
w_mat = netrw(g1, walker.num = num_nodes, damping = 1, T = num_steps, output.walk.path = TRUE) # get vertex sequence of random walk
visit_probability = w_mat$ave.visit.prob
g1_degree = degree(g1,mode = "in")
plot(g1_degree,visit_probability, main = "Visit Probability for Directed Graph", xlab = "Degree", ylab = "Visiting Probability")
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
library("netrw", lib.loc="~/R/win-library/2.15")
library("igraph", lib.loc="~/R/win-library/2.15")
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
num_nodes <- 1000
num_steps <- 1000
g3 <-random.graph.game(n = num_nodes, p = 0.01 , directred = FALSE)
w_mat = netrw(g3, walker.num = num_nodes, damping = 0.85, T = num_steps, output.walk.path = TRUE) # get vertex sequence of random walk
visit_probability = w_mat$ave.visit.prob
g3_degree = degree(g3,mode)
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q1.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q4.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q4.R')
sum(page_rank)
source('C:/Users/Steven/Desktop/EE232E-HW2/Q4.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q4.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q4.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q4.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q4.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q4.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q4.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q4.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q4.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q4.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q4.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q4.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q4.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q4.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q4.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q4.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q4.R')
plot(c(0,0),c(1,1))
plot(c(0,0),c(1,1),type="b")
plot(c(0,1),c(0,1),type="b")
source('C:/Users/Steven/Desktop/EE232E-HW2/Q4.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q4.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q4.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q4.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q4.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q4.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
plot(g1_degree,visit_probability, main = "Visit Probability for Undirected Graph", xlab = "Degree", ylab = "Visiting Probability", ylim = c(0,.0025))
plot(g1_degree,visit_probability, main = "Visit Probability for Undirected Graph with Teleportation (damping = 0.85)", xlab = "Degree", ylab = "Visiting Probability", ylim = c(0,.0025) )
# This code is programmed in R v2.15.2.with iGraph v0.7.0 and netrw v0.2.6
# Homework 2 Question 3
# clearing workspace
closeAllConnections()
rm(list=ls())
# Load libraries
library("igraph")
library("netrw")
############################### Part a ###############################
# generate graph from 1a
num_nodes <- 1000
num_steps <- 1000
g1 <- erdos.renyi.game(n = num_nodes, p = 0.01 , directed = FALSE)
w_mat = netrw(g1, walker.num = num_nodes, damping = 1, T = num_steps, output.walk.path = TRUE) # get vertex sequence of random walk
visit_probability = w_mat$ave.visit.prob
g1_degree = degree(g1)
plot(g1_degree,visit_probability, main = "Visit Probability for Undirected Graph", xlab = "Degree", ylab = "Visiting Probability", ylim = c(0,.0025))
w_mat = netrw(g1, walker.num = num_nodes, damping = .85, T = num_steps, output.walk.path = TRUE) # get vertex sequence of random walk
visit_probability = w_mat$ave.visit.prob
g1_degree = degree(g1)
plot(g1_degree,visit_probability, main = "Visit Probability for Undirected Graph with Teleportation (damping = 0.85)", xlab = "Degree", ylab = "Visiting Probability", ylim = c(0,.0025) )
source('C:/Users/Steven/Desktop/EE232E-HW2/Q4.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q3.R')
source('C:/Users/Steven/Desktop/EE232E-HW2/Q2.R')
graph_data = read.table("sorted_directed_net.txt", sep = "\t", header = FALSE) # read sorted directed network
library(igraph)
library(netrw)
graph_data = read.table("sorted_directed_net.txt", sep = "\t", header = FALSE) # read sorted directed network
library(igraph)
library(netrw)
graph_data = read.table("sorted_directed_net.txt", sep = "\t", header = FALSE) # read sorted directed network
ver
version
graph_data = read.table("sorted_directed_net.txt") #, sep = "\t", header = FALSE) # read sorted directed network
library("igraph")
graph_data <- read.table("sorted_directed_net
graph_data <- read.table("sorted_directed_net
graph_data <- read.table("sorted_directed_net
graph_data <- read.table("sorted_directed_net
# This code is programmed in R v2.15.2.with iGraph v0.7.0 and netrw v0.2.6
# clearing workspace
closeAllConnections()
rm(list=ls())
# Load libraries
library("igraph")
library("netrw")
####################  QUESTION 1 ####################
graph_data <- read.table("sorted_directed_net.txt", sep = "\t", header = FALSE) # read text file
colnames(graph_data) <- c("Node 1", "Node 2", "weights")
g1 <- graph.data.frame(graph_data,directed = TRUE) # covert table to directed garph
connectivity <- is.connected(g1) #check if network is connected
# This code is programmed in R v2.15.2.with iGraph v0.7.0 and netrw v0.2.6
# clearing workspace
closeAllConnections()
rm(list=ls())
# Load libraries
library("igraph")
library("netrw")
####################  QUESTION 1 ####################
graph_data <- read.table("sorted_directed_net.txt", sep = "\t", header = FALSE) # read text file
colnames(graph_data) <- c("Node 1", "Node 2", "weights")
g1 <- graph.data.frame(graph_data,directed = TRUE) # covert table to directed garph
closeAllConnections()
rm(list=ls())
library("igraph")
library("netrw")
graph_data <- read.table("sorted_directed_net.txt", sep = "\t", header = FALSE) # read text file
source('C:/Users/Steven/Desktop/EE232E_HW3/HW3.R')
print('steven')
cat('steven')
cat(' ########## QUESTION 1 ##########')
cat(' ########## QUESTION 1 ########## \n)
graph_data <- read.table("sorted_directed_net.txt", sep = "\t", header = FALSE) # read text file
colnames(graph_data) <- c("Node 1", "Node 2", "weights")
g1 <- graph.data.frame(graph_data,directed = TRUE) # covert table to directed garph
connectivity <- is.connected(g1,mode = "strong") #check if network is connected
if (connectivity == 1) {
sprintf('The network is connected')
} else {
sprintf('The newtork is not connected')
cl <- clusters(g1, mode = "strong")
gccIndex <- which.max(cl$csize)
nonGCCnodes <- (1:vcount(g1))[cl$membership != gccIndex]
gcc <- delete.vertices(g1,nonGCCnodes)
}
####################  QUESTION 2 ####################
g1_indeg <- degree(gcc , mode = "in")
g1_outdeg <- degree(gcc , mode = "out")
hist(g1_indeg, breaks <- seq(from = min(g1_indeg), to = max(g1_indeg), by=1),main = "GCC In-Degree Distribution",xlab = "In-Degree",ylab = "Frequency")
hist(g1_outdeg, breaks <- seq(from = min(g1_outdeg), to = max(g1_outdeg), by=1),main = "GCC Out-Degree Distribution",xlab = "Out-Degree",ylab = "Frequency")
####################  QUESTION 3 ####################
# option 1 : keep the number of edges unchanged, and just remove the directions
# using label.propagation.community
undirected_1 <- as.undirected(gcc, mode = "each")
community_1 <- label.propagation.community(undirected_1, weights = E(undirected_1)$weights)
m_1 <- modularity(community_1)
s_1 <- sizes(community_1)
# option 2 : merge the two directed edges between i and j
edge_weights <- function(weight) sqrt(prod(weight))
undirected_2 <- as.undirected(gcc, mode = "collapse", edge.attr.comb = edge_weights)
# using label.propagation.community
community_2a <- label.propagation.community(undirected_2, weights = E(undirected_2)$weights)
m_2a <- modularity(community_2a)
s_2a <- sizes(community_2a)
# using fastgreedy.community
community_2b <- fastgreedy.community(undirected_2, weights = E(undirected_2)$weights)
m_2b <- modularity(community_2b)
s_2b <- sizes(community_2b)
####################  QUESTION 4 ####################
# Sub GCC
max_com_index <- which.max(s_2b)
non_sub_GCC_nodes <- (1:vcount(undirected_2))[community_2b$membership != max_com_index]
sub_GCC <- delete.vertices(undirected_2, non_sub_GCC_nodes)
# Sub GCC Community
sub_GCC_com <- fastgreedy.community(sub_GCC, weights=E(sub_GCC)$weights)
sub_GCC_m <- modularity(sub_GCC_com)
sub_GCC_s <- sizes(sub_GCC_com)
####################  QUESTION 5 ####################
large_community_index = which(sizes(community_2b) > 100)
for (i in 1:length(large_community_index)) {
nodes_to_del <- (1:vcount(undirected_2))[community_2b$membership != large_community_index[i]]
temp_sub_graph <- delete.vertices(undirected_2, nodes_to_del)
temp_sub_com <- fastgreedy.community(temp_sub_graph)
# Print results
cat('\n Sub-Community number', i , 'whose size greater than 100 \n')
cat('Modularity: ',modularity(temp_sub_com),'\n')
print(sizes(temp_sub_com))
cat('\n')
}
cat(' ########## QUESTION 1 ########## \n')
graph_data <- read.table("sorted_directed_net.txt", sep = "\t", header = FALSE) # read text file
colnames(graph_data) <- c("Node 1", "Node 2", "weights")
g1 <- graph.data.frame(graph_data,directed = TRUE) # covert table to directed garph
connectivity <- is.connected(g1,mode = "strong") #check if network is connected
if (connectivity == 1) {
sprintf('The network is connected')
} else {
sprintf('The newtork is not connected')
cl <- clusters(g1, mode = "strong")
gccIndex <- which.max(cl$csize)
nonGCCnodes <- (1:vcount(g1))[cl$membership != gccIndex]
gcc <- delete.vertices(g1,nonGCCnodes)
}
# This code is programmed in R v2.15.2.with iGraph v0.7.0 and netrw v0.2.6
# clearing workspace
closeAllConnections()
rm(list=ls())
# Load libraries
library("igraph")
library("netrw")
####################  QUESTION 1 ####################
cat(' ########## QUESTION 1 ########## \n')
graph_data <- read.table("sorted_directed_net.txt", sep = "\t", header = FALSE) # read text file
colnames(graph_data) <- c("Node 1", "Node 2", "weights")
g1 <- graph.data.frame(graph_data,directed = TRUE) # covert table to directed garph
connectivity <- is.connected(g1,mode = "strong") #check if network is connected
if (connectivity == 1) {
sprintf('The network is connected')
} else {
sprintf('The newtork is not connected')
cl <- clusters(g1, mode = "strong")
gccIndex <- which.max(cl$csize)
nonGCCnodes <- (1:vcount(g1))[cl$membership != gccIndex]
gcc <- delete.vertices(g1,nonGCCnodes)
}
source('C:/Users/Steven/Desktop/EE232E_HW3/HW3_q1.R')
setwd("C:/Users/Steven/Desktop/EE232E_HW3")
# This code is programmed in R v2.15.2.with iGraph v0.7.0 and netrw v0.2.6
# clearing workspace
closeAllConnections()
rm(list=ls())
# Load libraries
library("igraph")
library("netrw")
####################  QUESTION 1 ####################
cat(' ########## QUESTION 1 ########## \n')
graph_data <- read.table("sorted_directed_net.txt", sep = "\t", header = FALSE) # read text file
colnames(graph_data) <- c("Node 1", "Node 2", "weights")
g1 <- graph.data.frame(graph_data,directed = TRUE) # covert table to directed garph
connectivity <- is.connected(g1,mode = "strong") #check if network is connected
if (connectivity == 1) {
sprintf('The network is connected')
} else {
sprintf('The newtork is not connected')
cl <- clusters(g1, mode = "strong")
gccIndex <- which.max(cl$csize)
nonGCCnodes <- (1:vcount(g1))[cl$membership != gccIndex]
gcc <- delete.vertices(g1,nonGCCnodes)
}
source('C:/Users/Steven/Desktop/EE232E_HW3/HW3_q1.R')
source('C:/Users/Steven/Desktop/EE232E_HW3/HW3_q1.R')
cat('steven \n \n')
source('C:/Users/Steven/Desktop/EE232E_HW3/HW3_q1.R')
source('C:/Users/Steven/Desktop/EE232E_HW3/HW3_q1.R')
source('C:/Users/Steven/Desktop/EE232E_HW3/HW3_q1.R')
source('C:/Users/Steven/Desktop/EE232E_HW3/HW3_q1.R')
source('C:/Users/Steven/Desktop/EE232E_HW3/HW3_q1.R')
source('C:/Users/Steven/Desktop/EE232E_HW3/HW3_q1.R')
source('C:/Users/Steven/Desktop/EE232E_HW3/HW3_q1.R')
source('C:/Users/Steven/Desktop/EE232E_HW3/HW3_q1.R')
source('C:/Users/Steven/Desktop/EE232E_HW3/HW3_q1.R')
source('C:/Users/Steven/Desktop/EE232E_HW3/HW3_q1.R')
source('C:/Users/Steven/Desktop/EE232E_HW3/HW3_q1.R')
